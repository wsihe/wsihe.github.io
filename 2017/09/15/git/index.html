<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="keywords" content="river,前端,设计,前端开发,用户体验,设计,frontend,design,nodejs,JavaScript"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="icon" href="/source/images/favicon.ico"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><title>Git 提交规范</title><body><div class="container"><div class="nav"><ul><li class="item"><a href="/">主页</a></li><li class="item"><a href="/archives">归档</a></li><li class="item"><a href="/about/">关于</a></li></ul></div><article><header><h1 class="title">Git 提交规范</h1><i class="icon-calendar"></i><span>2017.09.15</span></header><div class="content"><h2 id="规范1："><a href="#规范1：" class="headerlink" title="规范1："></a>规范1：</h2><p>格式化提交信息，commit message 都包括三个部分：Header，Body 和 Footer:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>
<p>其中，Header 是必需的，Body 和 Footer 可以省略。</p>
<h4 id="Revert"><a href="#Revert" class="headerlink" title="Revert"></a>Revert</h4><p>如果你使用revert命令，信息头必须以revert:开始，接着在主体信息（body）中必须声明：This reverts commit <hash>.,这里的hash是被 revert 的 commit hash。</hash></p>
<h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><p>Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。</p>
<p>（1）type</p>
<p>可以使用下面的类型：</p>
<ul>
<li>feat​ (新功能)</li>
<li>fix​ (问题修复)</li>
<li>docs​ (文档)</li>
<li>style​ (格式)</li>
<li>refactor（重构）</li>
<li>test​ (增加测试)</li>
<li>chore​ (一些变动)</li>
</ul>
<p>（2）scope</p>
<p>Scope 可以是任何一个具体的变更信息的位置，比如说 $location​,$browser​, $compile​, $rootScope​, ngHref​, ngClick​, ngView​,等等。</p>
<p>你可以使用 * 来描述不太合适的 scope.</p>
<p>（3）subject</p>
<p>这里只要很简洁的描述就可以，不要超过50字。</p>
<ul>
<li>使用第一人称现在时</li>
<li>第一个字母小写</li>
<li>结尾不加句号</li>
</ul>
<h4 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h4><ul>
<li>使用第一人称现在时</li>
<li>包括变动的原因和与之前的对比</li>
</ul>
<h4 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h4><p>Footer 部分只用于两种情况。</p>
<p>（1）不兼容改动</p>
<p>所有不兼容变更需要放在 footer 上，并且以 BREAKING CHANGE开始，后面是对变更的描述以及理由和迁移方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed and</span><br><span class="line">    the inject option for the directive controller injection was removed.</span><br><span class="line">    To migrate the code follow the example below:</span><br><span class="line"></span><br><span class="line">    Before:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">        myAttr: &apos;attribute&apos;,</span><br><span class="line">        myBind: &apos;bind&apos;,</span><br><span class="line">        myExpression: &apos;expression&apos;,</span><br><span class="line">        myEval: &apos;evaluate&apos;,</span><br><span class="line">        myAccessor: &apos;accessor&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    After:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">        myAttr: &apos;@&apos;,</span><br><span class="line">        myBind: &apos;@&apos;,</span><br><span class="line">        myExpression: &apos;&amp;&apos;,</span><br><span class="line">        // myEval - usually not useful, but in cases where the expression is assignable, you can</span><br><span class="line">        use &apos;=&apos;</span><br><span class="line">        myAccessor: &apos;=&apos; // in directive&apos;s template change myAccessor() to myAccessor</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    The removed `inject` wasn&apos;t generaly useful for directives so there should be no code</span><br><span class="line">    using it.</span><br></pre></td></tr></table></figure>
<p>（2）关联issues</p>
<p>关闭 issues 必须在 footer 区域的分开的一行，以“Closes”关键词开头：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Close #234</span><br></pre></td></tr></table></figure></p>
<p>当然也可以关闭多个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Close #123, #245, #992</span><br></pre></td></tr></table></figure>
<h3 id="Commitizen"><a href="#Commitizen" class="headerlink" title="Commitizen"></a>Commitizen</h3><p><a href="">Commitizen</a>是一个撰写合格 Commit message 的工具。</p>
<p>安装命令如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g commitizen</span><br></pre></td></tr></table></figure>
<p>然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure>
<p>以后，凡是用到git commit命令，一律改为使用git cz。这时，就会出现选项，用来生成符合格式的 Commit message。</p>
<h3 id="为什么要这么做"><a href="#为什么要这么做" class="headerlink" title="为什么要这么做"></a>为什么要这么做</h3><p>1.允许通过脚本自动生成变更日志<br>2.允许通过命令过滤某些提交信息（例如不重要的格式变动信息）<br>3.提供更多的历史记录信息</p>
<h4 id="快速生成变更日志"><a href="#快速生成变更日志" class="headerlink" title="快速生成变更日志"></a>快速生成变更日志</h4><p>我们在变更日志中使用这三个部分：新特性、问题修复（bug fix）、不兼容变更（breaking change）。</p>
<p>这些列表可以在发布更新的时候通过脚本生成，并链接到相关的提交记录。</p>
<p>当然你可以在发布之前编辑变更日志，不过这种方式能帮助我们生成整体架构。</p>
<p>列出所有从上一次发布的提交信息的第一行：</p>
<p>git log <last tag=""> HEAD –pretty=format:%s</last></p>
<p>列出本次发布的新功能：</p>
<p>git log <last release=""> HEAD –grep feature</last></p>
<h4 id="过滤不重要的提交信息"><a href="#过滤不重要的提交信息" class="headerlink" title="过滤不重要的提交信息"></a>过滤不重要的提交信息</h4><p>这些不重要的信息指的是格式上改变（增加或删除多余的行以及缩进），缺少分号、注释。所以当你在找一些变更的时候可以忽略这些。</p>
<p>你可以使用这个命令：</p>
<p>git bisect skip $(git rev-list –grep irrelevant <good place=""> HEAD)</good></p>
<h4 id="提供更多的历史信息"><a href="#提供更多的历史信息" class="headerlink" title="提供更多的历史信息"></a>提供更多的历史信息</h4><p>看看这些提交信息，一部分来自最近 Angular 的提交，这样的提交信息会增加一种环境信息。</p>
<ul>
<li>Fix small typo in docs widget (tutorial instructions)</li>
<li>Fix test for scenario.Application - should remove old iframe</li>
<li>docs - various doc fixes</li>
<li>docs - stripping extra new lines</li>
<li>Replaced double line break with single when text is fetched from Google</li>
<li>Added support for properties in documentation</li>
</ul>
<p>下面这些信息试图详细描述哪里发生了变化，但没有任何规则…</p>
<ul>
<li>fix comment stripping</li>
<li>fixing broken links</li>
<li>Bit of refactoring</li>
<li>Check whether links do exist and throw exception</li>
<li>Fix sitemap include (to work on case sensitive linux)</li>
</ul>
<p>看到这些你能猜出这里面到底有些变化吗？它们都缺少了“特定位置规范”（place specification）…所以使用下面这些词语：docs,docs-parser,compiler,scenario-runner,…</p>
<p>我知道你能通过查看哪些文件变更来找寻这些信息，但是效率不高。通过使用这些规范来查看 git 的历史提交信息能看到我们所有描述的改动地方。</p>
<p>更新详情可以参考 <a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">Commit message 和 Change log 编写指南</a></p>
<h2 id="规范2："><a href="#规范2：" class="headerlink" title="规范2："></a>规范2：</h2><p>git push修改到仓库前，需先执行<code>git pull --rebase</code>命令，拉取+叠加+合并仓库他人修改后，再push。</p>
<h3 id="为什么要这么做-1"><a href="#为什么要这么做-1" class="headerlink" title="为什么要这么做"></a>为什么要这么做</h3><p>在项目日常迭代开发中，我们的git协作流程是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 1. 拉取仓库最新修改</span><br><span class="line">~ git pull</span><br><span class="line"># 2. 本地完成了某个功能特性开发，开始commit到本地仓库</span><br><span class="line">~ git commit -m &quot;message&quot;</span><br><span class="line"></span><br><span class="line"># 3. push到远程仓库，共享给其他人</span><br><span class="line">~ git push origin develop</span><br></pre></td></tr></table></figure>
<p>当项目是多人协作开发时，难以避免出现两个人基于同一版本提交了不同的commit，此时在第3步操作前，我们需要再次用git pull拉取合并仓库最新修改，合并成功后才允许push：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 1. 拉取仓库最新修改</span><br><span class="line">~ git pull</span><br><span class="line"></span><br><span class="line"># 2. 本地完成了某个功能特性开发，开始commit到本地仓库</span><br><span class="line">~ git commit -m &quot;message&quot;</span><br><span class="line"></span><br><span class="line"># 3. 再次拉取仓库最新修改，合并他人修改（git自动合并）</span><br><span class="line">~ git pull</span><br><span class="line"></span><br><span class="line"># 4. push到远程仓库，共享给其他人</span><br><span class="line">~ git push origin develop</span><br></pre></td></tr></table></figure>
<p>第三步操作时，git会自动产生一条“Merge branch ‘develop’ of ssh://xxx into develop”的commit log：</p>
<p>这些merge log无附带其他修改信息，只是作为分支合并比较，在本地分支修改上合并了仓库分支修改。但项目commit频繁，短时间内会产生大量的merge log，例如：</p>
<p>导致的后果是：</p>
<p>项目git log混乱，正常修改被淹没在大量无意义的merge log中，难以清晰地呈现修改衍变历史；<br>追溯某个文件的git commit历史修改时，merge log会扰乱修改路径。</p>
<p>解决这种问题的方式是，在 <code>git pull</code> 时加上 <code>--rebase</code>选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~ git pull</span><br><span class="line">~ git commit -m &quot;message&quot;</span><br><span class="line">~ git pull --rebase</span><br><span class="line">~ git push origin develop</span><br></pre></td></tr></table></figure>
<p><code>git pull --rebase</code>的作用是先备份本地<code>commit</code>，拉取仓库最新修改后，恢复本地commit，将本地commit叠加应用到仓库最新修改上，具体细节可参考<a href="https://isming.me/2014/09/26/git-rebase-merge/" target="_blank" rel="noopener">《git中merge和rebase的区别》</a>文章说明。</p>
<p>rebase选项可以拉直多人分支修改日志，即使短时间内大家频繁<code>commit &amp; push</code>，也无需担心log线条交叉问题：</p>
<h3 id="git-pull-–rebase的处理流程"><a href="#git-pull-–rebase的处理流程" class="headerlink" title="git pull –rebase的处理流程"></a>git pull –rebase的处理流程</h3><p>1.将本地未push到远程仓库的commit暂存起来；<br>2.回到上次pull时节点；<br>3.拉取并应用远程仓库最新commit；<br>4.应用刚才暂存的本地commit。</p>
<p>第4步叠加合并commit时，本地commit可能会与远程commit产生冲突，需要先解决冲突后（Resolving Conflicts），再执行git rebase –continue完成rebase过程。</p>
<p>git冲突的解决方式，首选Web Strom提供的<code>Resolving Conflicts</code>功能，借助图形化工具可视化操作：</p>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><p>1、什么时候可以不用加rebase选项<br>从上次push之后，本地没有新commit，可以直接执行 git pull，拉取远程仓库最新修改。</p>
<p>2、本地新修改尚未commit，直接执行<code>git pull --rebase</code>会报”error: Cannot pull with rebase: You have unstaged changes.”错误，怎么处理<br>根据提示，需要先将未commit的修改暂存起来，即执行git stash命令，应用stash功能。完成git pull –rebase后，再执行 git stash pop命令，还原修改。</p>
<p>一个完整的pull示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~ git stash                       # 暂存本地临时修改</span><br><span class="line">~ git pull --rebase               # 拉取并合并远程仓库commit</span><br><span class="line">~ git push origin develop         # 推送本地commit到远程仓库</span><br><span class="line">~ git pull                        # 更新同步本地origin/xxx分支版本</span><br><span class="line">~ git stash pop                   # 还原本地临时修改</span><br></pre></td></tr></table></figure>
<p>3、<code>git pull</code>时忘记加rebase选项，已产生merge日志，怎样处理，才能去掉merge日志，重新拉直分支线？<br> 再次执行git pull –rebase命令。</p>
</div></article></div></body></head></html>