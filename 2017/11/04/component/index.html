<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="keywords" content="river,前端,设计,前端开发,用户体验,设计,frontend,design,nodejs,JavaScript"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="icon" href="/source/images/favicon.ico"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><title>组件化实践方案</title><body><div class="container"><div class="nav"><ul><li class="item"><a href="/">主页</a></li><li class="item"><a href="/archives">归档</a></li><li class="item"><a href="/about/">关于</a></li></ul></div><article><header><h1 class="title">组件化实践方案</h1><i class="icon-calendar"></i><span>2017.11.04</span></header><div class="content"><h2 id="为什么要前端组件化？"><a href="#为什么要前端组件化？" class="headerlink" title="为什么要前端组件化？"></a>为什么要前端组件化？</h2><p>传统开发方式效率低以及维护成本高的主要原因在于很多时候是将一个系统做成了整块应用， 而且往往随着业务的增长或者变更，系统的复杂度会呈现指数级的增长， 经常出现的情况就是一个小小的改动或者一个小功能的增加可能会引起整体逻辑的修改，造成牵一发而动全身，很难实现多人协作。</p>
<p>针对此弊端，其实业界早就有了一些探索，我们希望一个大且复杂的场景能够被分解成几个小的部分，这些小的部分彼此之间互不干扰，可以单独开发，单独维护，而且他们之间可以随意的进行组合——这就是组件化。</p>
<p>随着angular,React等以组件（指令等）为主的优秀前端框架的出现， 前端组件化逐渐成为前端开发的迫切需求，当然这一迫切需求也逐渐成为一种主流，一种共识， 开发者们不需要再面对一堆复杂且难阅读的代码，转而只需要关注以组件方式存在的代码片段。</p>
<h2 id="怎样设计一个组件"><a href="#怎样设计一个组件" class="headerlink" title="怎样设计一个组件"></a>怎样设计一个组件</h2><p>一份真正成熟可靠的组件化方案，需要具备的能力。</p>
<h3 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h3><p>任何一个组件都应该遵守一套标准，可以使得不同区域的开发人员据此标准开发出一套标准统一的组件。</p>
<h3 id="专一"><a href="#专一" class="headerlink" title="专一"></a>专一</h3><p>要想设计一个好的组件，组件也需要专一。</p>
<p>任何一个组件应该都具有一套自己的完整的稳定的功能，仅包含自身的，与其它组件无关的逻辑，使其更加的容易理解，使其更加的容易理解，同时大大减少发生bug的几率。</p>
<p>一个功能如果可以拆分成多个功能点，那就可以将每个功能点封装成一个组件，当然也不是组件的颗粒度越小越好，只要将一个组件内的功能和逻辑控制在一个可控的范围内即可。</p>
<p>举个例子。页面上有一个 Table 列表和一个分页控件，就可以将 Table 封装为一个组件，分页控件 封装成一个组件，最后再把 Table组件 和 分页组件 封装成一个组件。Table 组件还可以再拆分成多个 table-column 组件，及展示逻辑等。</p>
<h3 id="可配置性"><a href="#可配置性" class="headerlink" title="可配置性"></a>可配置性</h3><p>一个组件，要明确它的输入和输出分别是什么。</p>
<p>组件除了要展示默认的内容，还需要做一些动态的适配，比如：一个组件内有一段文本，一个图片和一个按钮。那么字体的颜色、图片的规则、按钮的位置、按钮点击事件的处理逻辑等，都是可以做成可配置的。</p>
<p>要做可配置性，最基本的方式是通过属性向组件传递配置的值，而在组件初始化的声明周期内，通过读取属性的值做出对应的显示修改。还有一些方法，通过调用组件暴露出来的函数，向函数传递有效的值；修改全局 CSS样式；向组件传递特定事件，并在组件内监听该事件来执行函数等。</p>
<p>在做可配置性时，为了让组件更加健壮，保证组件接收到的是有效的属性、函数接收到的是有效的参数，需要做一些校验。</p>
<p>一. 属性的值的校验</p>
<p>对属性的值进行校验，一般要考虑以下几个方面。</p>
<p>1.属性值的类型是否是有效的。如果某个属性要求传递一个数组，那么传递过来的值不是数组时，就要抛出异常，并给出对应的提示。</p>
<p>2.属性是否是必填的。有的属性的值，是组件内不可缺少的时，就要是必填的，在组件初始化时要做是否传递的检查，如果没有传递，则需要抛出异常，并给出相应的提示。如果属性不是必填的，可以设定一个默认值，当属性没有被设置时，就使用默认值。</p>
<p>得益于 React、Vue 内部实现的属性检查，且这些属性检查会在组件初始化阶段默认执行，你可以很容易的给组件设置属性的检查。React 中可以使用 React.PropTypes 进行类型检查设置，Vue 中只需要给组件设置 props 即可。</p>
<p>二. 函数的参数的校验</p>
<p>函数的参数校验，只要按照传统的方法进行校验即可。在函数内部顶部判断参数的值和类型，如果不满足要求，则抛出异常，并给出相应的提示。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>一个组件，需要明确知道在生命周期的不同阶段做该做的事。</p>
<p>初始化阶段，读取属性的值，如果需要做数据和逻辑处理的话，在这个阶段进行。</p>
<p>属性值变化时，如果属性发生变化，且需要对变化后的数据进行处理的话，在这个阶段进行处理。</p>
<p>组件销毁阶段，如果组件已经创建了一些可能会对系统产生一些副作用的东西，可以在这个阶段进行清除。比如 timeInterval、timeout 等。</p>
<p>如果组件在渲染的时候报错，需要展示错误信息。React v16 中提供了 componentDidCatch 生命周期函数，Vue v2.5 中提供了 errorCaptured 的钩子函数。</p>
<p>React 中提供了一些生命周期函数：componentWillMount，componentDidMount，componentWillReceiveProps，shouldComponentUpdate，componentWillUpdate，componentDidUpdate，render，componentWillUnmount，componentDidCatch(React v16)。</p>
<p>Vue 中提供了一些生命周期函数：beforeCreate，created，beforeMount，mounted，beforeUpdate，updated，beforeDestroy，destroyed，errorCapture，errorCaptured(Vue v2.5)。</p>
<h3 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h3><p>Vue 中传递事件很简单，只需要在子组件内使用 this.$emit(‘event1’) 即可向外传递一个事件 event1，在父组件调用该子组件时，只需要监听 event1 事件，并给出对应事件处理逻辑即可。</p>
<p>而在 React 中，官方没有给出组件间的事件传递解决方案，这也是 React 中比较坑的一点。不过，还是可以使用其他方式来实现。</p>
<p>React 中，父组件可以使用 props 向子组件传值，而子组件向父组件传值，需要在父组件内定义函数并通过属性传递给子组件，在子组件内通过调用该属性对应的函数，传入参数，传递给父组件内的函数，并在父组件的该函数中做逻辑的处理。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>对组件的理解不能停留在实现的形式上，还要统筹大局，坚持并持续优化。</p>
</div></article></div></body></head></html>