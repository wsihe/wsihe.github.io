<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="keywords" content="river,前端,设计,前端开发,用户体验,设计,frontend,design,nodejs,JavaScript"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><title>Vue 开发经验 - 总结</title><body><div class="container"><div class="nav"><ul><li class="item"><a href="/">主页</a></li><li class="item"><a href="/archives">归档</a></li><li class="item"><a href="/about/">关于</a></li></ul></div><article><header><h1 class="title">Vue 开发经验 - 总结</h1><i class="icon-calendar"></i><span>2017.06.26</span></header><div class="content"><h3 id="怎么学习Vue？"><a href="#怎么学习Vue？" class="headerlink" title="怎么学习Vue？"></a>怎么学习Vue？</h3><ol>
<li>前置条件是 JavaScript / HTML / CSS 基本功，然后通读<a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="external">官方教程 (guide)</a> 的基础篇，引入vue实现教程中的例子。</li>
<li>阅读官方教程进阶篇『自定义指令 (Custom Directive) ]』前的半部分，着重对 Vue 的响应式机制和组件生命周期的理解，<a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="external">『渲染函数（Render Function)』</a>对编写可复用的组件，有时候很重要。</li>
<li>上面都是一些vue的基本学习，但是要更深入的了解怎么搭建一个大型 Vue 工程，还要深入学习前端生态/工程化相关的知识（node／Webpack），之后可以通过 <a href="https://github.com/vuejs/vue-cli" target="_blank" rel="external">vue-cli</a> 来搭建支持热重载的项目。</li>
<li>有需要的话，可以学习 vue-router ／ vuex ／服务端渲染，理解他们解决了什么问题，我们是否真的需要它。</li>
<li>除了自己亲手搭建实际的项目外，还可以阅读开源的 Vue 组件、插件源码，例如<a href="https://github.com/ElemeFE/element" target="_blank" rel="external">element组件</a>，然后尝试编写开源的 Vue 组件、插件。</li>
<li>再深入的话，可以阅读 Vue 的源码并实现一些其中功能，例如<a href="/2017/06/10/defineproperty1/" title="JavaScript 实现监听一个对象的变化">JavaScript 实现监听一个对象的变化</a>。</li>
<li>除此之外，看大神对各大框架的对比（争论），也能帮我们更快的了解各大框架的区别，还有他们的优势所在。推荐阅读 <a href="https://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&amp;mid=2247484393&amp;idx=1&amp;sn=142b8e37dfc94de07be211607e468030&amp;chksm=9723612ba054e83db6622a891287af119bb63708f1b7a09aed9149d846c9428ad5abbb822294&amp;mpshare=1&amp;scene=23&amp;srcid=1117xibGjH860bGrbWS3TNT1#rd" target="_blank" rel="external">Vue 2.0，渐进式前端解决方案</a></li>
<li>最后可以认真学习下其他框架，你会发现他们有异曲同工之妙，例react的JSX语法对我们学习『渲染函数（Render Function)』比较有帮助</li>
</ol>
<h3 id="Vue是什么？"><a href="#Vue是什么？" class="headerlink" title="Vue是什么？"></a>Vue是什么？</h3><p>Vue核心只解决一个很小的问题（声明式渲染和组件系统），但它们有生态圈及配套的可选工具，当把他们一个一个加进来的时候，就可以组合成非常强大的栈，可以涵盖其他的这些更完整的框架所涵盖的问题，所以vue应该算是渐进式的UI框架。</p>
<h3 id="Vue的组件化？"><a href="#Vue的组件化？" class="headerlink" title="Vue的组件化？"></a>Vue的组件化？</h3><p>Vue的组件可以说是Vue中最神奇也是最难懂的部分了，这部分懂了，vue也就懂了。vue组件的特点是可插拔、独立作用域、观察者模式、完整的生命周期。我们来看一个组件的基本构成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;child&apos;, &#123;</div><div class="line">    props: [&apos;msg&apos;],</div><div class="line">    template: &apos;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&apos;,</div><div class="line">    data: function() &#123;</div><div class="line">        return &#123;</div><div class="line">            title: &apos;TalkingCoder&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    methods: &#123;</div><div class="line">        // ...</div><div class="line">    &#125;,</div><div class="line">    ready: function() &#123;</div><div class="line"></div><div class="line">    &#125;,</div><div class="line">    beforeDestroy: function() &#123;</div><div class="line"></div><div class="line">    &#125;,</div><div class="line">    events: &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>一个组件基本跟一个vue实例是类似的，也有自己的methods和data，只不过data是通过一个function来返回了一个对象，具体原因可以查看vue的文档。</p>
<p>props是从父级通过html特性传递来的数据，它可以是字符串、数字、布尔、数组、对象，默认是单向的，也可以设置为双向绑定的。props里的参数可以直接通过像this.msg这种方式调用，这与data的里的数据是一样的。</p>
<p>template是这个组件使用的html片段，可以直接是字符串，也可以像’#child’这样标识一个dom节点。</p>
<p>ready和beforeDestroy是两个常用的生命周期，ready是在组件准备好时的一个回调，一般在这里我们可以使用获取数据、实例化第三方组件、绑定事件等，beforeDestroy正好相反，是在组件即将被销毁时触发回调，在这里我们销毁自定义的实例、解绑自定义事件、定时器等。</p>
<h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt=""></p>
<p>组件在初始化时会触发的钩子函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    props: [&apos;父组建传的值&apos;],</div><div class="line">    data:function()&#123;</div><div class="line">        return &#123;</div><div class="line">            msg: &apos;各个阶段，可以查看控制台输出&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    beforeCreate:function()&#123;</div><div class="line">        // 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。</div><div class="line">    &#125;,</div><div class="line">    created:function()&#123;</div><div class="line">        // 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</div><div class="line">    &#125;,</div><div class="line">    beforeCreate:function()&#123;</div><div class="line">        // 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。</div><div class="line">    &#125;,</div><div class="line">    mounted:function()&#123;</div><div class="line">        // el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</div><div class="line">    &#125;,</div><div class="line">    beforeUpdate: function()&#123;</div><div class="line">        // 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</div><div class="line">        // 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</div><div class="line">    &#125;,</div><div class="line">    Update: function()&#123;</div><div class="line">        // 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</div><div class="line"></div><div class="line">        //当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    // &lt;keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。</div><div class="line">    activated: function()&#123;</div><div class="line">        // keep-alive 组件激活时调用。</div><div class="line">    &#125;,</div><div class="line">    deactivated: function()&#123;</div><div class="line">        // keep-alive 组件停用时调用。</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    beforeDestroy:function()&#123;</div><div class="line">        // 实例销毁之前调用。在这一步，实例仍然完全可用。</div><div class="line">    &#125;,</div><div class="line">    destroyed:function()&#123;</div><div class="line">        // Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Vue-响应式原理"><a href="#Vue-响应式原理" class="headerlink" title="Vue 响应式原理"></a>Vue 响应式原理</h3><p>把一个普通 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter<br><img src="https://cn.vuejs.org/images/data.png" alt=""></p>
<h3 id="Vue-Router路由"><a href="#Vue-Router路由" class="headerlink" title="Vue-Router路由"></a>Vue-Router路由</h3><p>Vue-Router就是Vue的一个组件，它并不会被渲染，只是一个创建内部路由规则的配置对象，根据匹配的路由地址展现相应的组件。</p>
<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>首先，Vuex并不是必须的，不是大型的单页应用，使用 Vuex 可能是繁琐冗余的，有时候一个简单的 global event bus 就足够整个项目的需求了。<br>其次，如果组件交流特别频繁，逻辑很复杂，那Vuex 的优势就特别明显了，像购物车这样的需求。</p>
<p>Vuex 我们可以把理解成一数据的集合，相当于一个“前端数据库”，让其在各个页面上实现数据的共享，并且可操作。</p>
<p><img src="https://vuex.vuejs.org/zh-cn/images/vuex.png" alt=""></p>
</div></article></div></body></head></html>