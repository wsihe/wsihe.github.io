<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="keywords" content="river,前端,设计,前端开发,用户体验,设计,frontend,design,nodejs,JavaScript"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><title>JavaScript 基础之事件详解</title><body><div class="container"><div class="nav"><ul><li class="item"><a href="/">主页</a></li><li class="item"><a href="/archives">归档</a></li><li class="item"><a href="/about/">关于</a></li></ul></div><article><header><h1 class="title">JavaScript 基础之事件详解</h1><i class="icon-calendar"></i><span>2017.12.26</span></header><div class="content"><p>事件是一种异步编程的实现方式，本质上是程序各个组成部分之间的通信。事件通常与函数配合使用，这样就可以通过发生的事件来驱动函数执行。<br><a id="more"></a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>什么是 JavaScript 事件？如何给动态添加的 DOM 元素添加事件？</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h4 id="DOM0级模型"><a href="#DOM0级模型" class="headerlink" title="DOM0级模型"></a>DOM0级模型</h4><p>又称为原始事件模型，在该模型中，事件不会传播，即没有事件流的概念。事件绑定监听函数比较简单, 有两种方式:</p>
<ul>
<li><p>HTML代码中直接绑定:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; onclick=&quot;fun()&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过JS代码指定属性值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&apos;.btn&apos;);</span><br><span class="line">btn.onclick = fun;</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除监听函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = null;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这种方式所有浏览器都兼容，但是逻辑与显示并没有分离。</p>
<h4 id="IE事件模型"><a href="#IE事件模型" class="headerlink" title="IE事件模型"></a>IE事件模型</h4><p>IE事件模型共有两个过程:</p>
<ul>
<li><p>事件处理阶段(target phase)。事件到达目标元素, 触发目标元素的监听函数。</p>
</li>
<li><p>事件冒泡阶段(bubbling phase)。事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</p>
</li>
</ul>
<p>事件绑定监听函数的方式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attachEvent(eventType, handler)</span><br></pre></td></tr></table></figure></p>
<p>事件移除监听函数的方式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">detachEvent(eventType, handler)</span><br></pre></td></tr></table></figure></p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&apos;.btn&apos;);</span><br><span class="line">btn.attachEvent(‘onclick’, showMessage);</span><br><span class="line">btn.detachEvent(‘onclick’, showMessage);</span><br></pre></td></tr></table></figure></p>
<h4 id="DOM2级模型"><a href="#DOM2级模型" class="headerlink" title="DOM2级模型"></a>DOM2级模型</h4><p>属于W3C标准模型，现代浏览器(除IE6-8之外的浏览器)都支持该模型。在该事件模型中，一次事件共有三个过程：事件捕获阶段、处于目标阶段、事件冒泡阶段。</p>
<p>事件捕获（event capturing）：通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。</p>
<p>事件冒泡（dubbed bubbling）：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点。</p>
<p>事件绑定监听函数的方式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(eventType, handler, useCapture)</span><br></pre></td></tr></table></figure></p>
<p>事件移除监听函数的方式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removeEventListener(eventType, handler, useCapture)</span><br></pre></td></tr></table></figure></p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var phases = &#123;</span><br><span class="line">  1: &apos;capture&apos;,</span><br><span class="line">  2: &apos;target&apos;,</span><br><span class="line">  3: &apos;bubble&apos;</span><br><span class="line">&#125;;~</span><br><span class="line"></span><br><span class="line">var div = document.querySelector(&apos;div&apos;);</span><br><span class="line">var p = document.querySelector(&apos;p&apos;);</span><br><span class="line"></span><br><span class="line">div.addEventListener(&apos;click&apos;, callback, true);</span><br><span class="line">p.addEventListener(&apos;click&apos;, callback, true);</span><br><span class="line">div.addEventListener(&apos;click&apos;, callback, false);</span><br><span class="line">p.addEventListener(&apos;click&apos;, callback, false);</span><br><span class="line"></span><br><span class="line">function callback(event) &#123;</span><br><span class="line">  var tag = event.currentTarget.tagName;</span><br><span class="line">  var phase = phases[event.eventPhase];</span><br><span class="line">  console.log(&quot;Tag: &apos;&quot; + tag + &quot;&apos;. EventPhase: &apos;&quot; + phase + &quot;&apos;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 点击以后的结果</span><br><span class="line">// Tag: &apos;DIV&apos;. EventPhase: &apos;capture&apos;</span><br><span class="line">// Tag: &apos;P&apos;. EventPhase: &apos;target&apos;</span><br><span class="line">// Tag: &apos;P&apos;. EventPhase: &apos;target&apos;</span><br><span class="line">// Tag: &apos;DIV&apos;. EventPhase: &apos;bubble&apos;</span><br></pre></td></tr></table></figure></p>
<p>捕获阶段：事件从<code>&lt;div&gt;</code>向<code>&lt;p&gt;</code>传播时，触发<code>&lt;div&gt;</code>的click事件；<br>目标阶段：事件从<code>&lt;div&gt;</code>到达<code>&lt;p&gt;</code>时，触发<code>&lt;p&gt;</code>的click事件；<br>目标阶段：事件离开<code>&lt;p&gt;</code>时，触发<code>&lt;p&gt;</code>的click事件；<br>冒泡阶段：事件从<code>&lt;p&gt;</code>传回<code>&lt;div&gt;</code>时，再次触发<code>&lt;div&gt;</code>的click事件。</p>
<h2 id="事件的代理"><a href="#事件的代理" class="headerlink" title="事件的代理"></a>事件的代理</h2><p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ul = document.querySelector(&apos;ul&apos;);</span><br><span class="line"></span><br><span class="line">ul.addEventListener(&apos;click&apos;, function(event) &#123;</span><br><span class="line">  if (event.target.tagName.toLowerCase() === &apos;li&apos;) &#123;</span><br><span class="line">    // some code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码的click事件的监听函数定义在<code>&lt;ul&gt;</code>节点，但是实际上，它处理的是子节点<code>&lt;li&gt;</code>的click事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而且以后再动态添加子节点，监听函数依然有效。</p>
</div></article></div></body></head></html>